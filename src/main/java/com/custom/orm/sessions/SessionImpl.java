package com.custom.orm.sessions;

import com.custom.orm.annotations.Id;
import com.custom.orm.annotations.relations.JoinColumn;
import com.custom.orm.annotations.relations.OneToOne;
import com.custom.orm.enums.CascadeType;
import com.custom.orm.mapper.FieldsMapper;
import com.custom.orm.mapper.FieldsMapperImpl;
import com.custom.orm.metadata.MetaDataManager;
import com.custom.orm.metadata.MetaDataManagerImpl;
import com.custom.orm.util.TableCreator;
import lombok.SneakyThrows;

import java.lang.reflect.Field;
import java.sql.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class SessionImpl implements Session {

    private Transaction transaction;

    MetaDataManager metaDataManager = new MetaDataManagerImpl();

    FieldsMapper fieldsMapper = new FieldsMapperImpl();

    TableCreator tableCreator = new TableCreator();

    @Override
    public Transaction beginTransaction() {
        transaction = new Transaction();
        transaction.begin();
        return transaction;
    }

    @SneakyThrows
    @Override
    public <T> T findById(Class<T> object, Long key) {

        String sql = "SELECT * FROM %s WHERE %s = ?";

        Connection connection = transaction.getConnection();

        PreparedStatement preparedStatement = connection.prepareStatement(String.format(
                sql,
                metaDataManager.getTableName(object),
                metaDataManager.getIdColumnName(object)));

        preparedStatement.setLong(1, key);

        T entity = object.getDeclaredConstructor().newInstance();

        ResultSet resultSet = preparedStatement.executeQuery();

        if (!resultSet.next()) {
            return null;
        }

        for (Field field : object.getDeclaredFields()) {
            fieldsMapper.fillFields(object, entity, resultSet, field);
        }
        return entity;
    }

    @SneakyThrows
    @Override
    public <T> List<T> findAll(Class<T> object) {

        String sql = "SELECT * FROM %s";

        Connection connection = transaction.getConnection();

        PreparedStatement preparedStatement = connection.prepareStatement(String.format(sql,
                metaDataManager.getTableName(object)));

        ResultSet resultSet = preparedStatement.executeQuery();

        List<T> result = new ArrayList<>();

        while (resultSet.next()) {
            T entity = object.getDeclaredConstructor().newInstance();
            for (Field field : object.getDeclaredFields()) {
                field.setAccessible(true);
                fieldsMapper.fillFields(object, entity, resultSet, field);
            }
            result.add(entity);
        }
        return result;
    }

/*
* This method adds the object to the database.
*
* @Id (key) of the object is generated by the database and after recording the object in the database,
* the key is returned and assigned to the object.
*
* Fields marked with the annotation @OneToOne are not entered into the database,
* they indicate the relationship of objects on the side of the Java application.
*
* If the CascadeType value "ALL" or "ADD" is present in the @OneToOne annotation,
* then when adding an object to the database, an object that has a relationship with our object will also be added.
*/
    @SneakyThrows
    @Override
    public <T> void create(T object) {
        //There should be a check to see if such a table exists in the database, method from Yura
        //System.out.println(tableCreator.createTableIfNotExists(object));


        String sql = "INSERT INTO %s (%s) VALUES (%s)";

        Connection connection = transaction.getConnection();

        PreparedStatement preparedStatement = connection.prepareStatement(String.format(
                sql,
                metaDataManager.getTableName(object.getClass()),
                metaDataManager.getColumnNames(object),
                metaDataManager.getColumnValues(object)), Statement.RETURN_GENERATED_KEYS);

        // Get all the declared fields of the object, excluding the fields when they are marked by the @OneToOne annotation
        // but not marked by the @JoinColumn annotation.
        List<Field> declaredFields = metaDataManager.getDeclaredFields(object);

        // Iterate through the array of the object's declared fields and pass the value of each field to the PreparedStatement.
        for (int i = 1; i < declaredFields.size(); i++) {
            Field field = declaredFields.get(i);
            field.setAccessible(true);

            // If the field has the @JoinColumn annotation, then we use reflection API
            // to get the object contained in this field and get the key (id) from this object.
            // This key is transferred to the PreparedStatement according to the column specified in @JoinColumn.
            if(field.isAnnotationPresent(JoinColumn.class)){
                Object fieldObject = object.getClass().getMethod("get" + fieldsMapper.firstLetterWordToUpperCase(field.getName())).invoke(object);
                Long idFieldObject = (Long) fieldObject.getClass().getMethod("getId").invoke(fieldObject);

                preparedStatement.setObject(i, idFieldObject);
                continue;
            }
            preparedStatement.setObject(i, field.get(object));
        }
        preparedStatement.executeUpdate();

        // Get the key (id) of the object that was added to the database and assign it to this object.
        fieldsMapper.setObjectGeneratedKeys(object, preparedStatement);

        // Get declared fields that are marked with the @OneToOne annotation, but are not marked with the @JoinColumn annotation.
        List<Field> oneToOneFields = metaDataManager.getOneToOneDeclaredFields(object);

        for (Field oneToOneField : oneToOneFields) {
            if(Arrays.asList(oneToOneField.getAnnotation(OneToOne.class).cascade()).contains(CascadeType.ALL) ||
                    Arrays.asList(oneToOneField.getAnnotation(OneToOne.class).cascade()).contains(CascadeType.ADD)){
                Object obj = object.getClass().getMethod("get" + fieldsMapper.firstLetterWordToUpperCase(oneToOneField.getName())).invoke(object);
                if(obj!=null) {
                    this.create(obj);
                }
            }
        }
    }

    @SneakyThrows
    @Override
    public <T> boolean update(T object) {

        String sql = "UPDATE %s SET %s WHERE id = %s";
        StringBuilder objectIdValue = new StringBuilder();
        StringBuilder columnAndValue = new StringBuilder();

        List<Field> declaredFields = Arrays.stream(object.getClass().getDeclaredFields())
                .filter(field -> !field.isAnnotationPresent(OneToOne.class))
                .collect(Collectors.toList());

        for (int i = 0; i < declaredFields.size(); i++) {
            Field field = declaredFields.get(i);
            field.setAccessible(true);

            Object value = field.get(object);
            if(value==null){
                continue;
            }

            if (field.isAnnotationPresent(Id.class)) {
                objectIdValue.append(value);
            } else {
                    columnAndValue.append(field.getName()).append(" = '").append(value).append("'");
                if (i < declaredFields.size() - 1) {
                    columnAndValue.append(",");
                }
            }
        }

        Connection connection = transaction.getConnection();

        return connection.prepareStatement(String.format(
                sql,
                metaDataManager.getTableName(object.getClass()),
                columnAndValue,
                objectIdValue)).execute();
    }

    @SneakyThrows
    @Override
    public <T> boolean delete(T object) {

        String sql = "DELETE FROM %s WHERE id = %s";

        Connection connection = transaction.getConnection();

        List<Field> oneToOneFields = Arrays.stream(object.getClass().getDeclaredFields())
                .filter(field -> field.isAnnotationPresent(OneToOne.class))
                .collect(Collectors.toList());

        for (Field oneToOneField : oneToOneFields) {
            if(Arrays.asList(oneToOneField.getAnnotation(OneToOne.class).cascade()).contains(CascadeType.ALL) ||
                    Arrays.asList(oneToOneField.getAnnotation(OneToOne.class).cascade()).contains(CascadeType.REMOVE)){
                Object obj = object.getClass().getMethod("get" + fieldsMapper.firstLetterWordToUpperCase(oneToOneField.getName())).invoke(object);
                if(obj!=null) {
                   delete(obj);
                }
            }
        }

        return connection.prepareStatement(String.format(sql,
                metaDataManager.getTableName(object.getClass()),
                metaDataManager.getIdColumnValues(object)))
                .execute();
    }

    @Override
    public void close() {
        transaction.close();
    }

    @Override
    public void cancelQuery() {
        transaction.rollback();
    }
}
